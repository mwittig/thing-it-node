module.exports = {
    metadata: {
        family: "camera",
        plugin: "camera",
        label: "foscam Â© Camera",
        tangible: true,
        discoverable: true,
        state: [{id: "video", label: "Video", type: {id: "video"}}],
        actorTypes: [],
        sensorTypes: [],
        services: [
            {id: "panLeft", label: "Pan Left"},
            {id: "panRight", label: "Pan Right"},
            {id: "tiltUp", label: "Tilt Up"},
            {id: "tiltDown", label: "Tilt Down"},
            {id: "savePosition", label: "Save Position"},
            {id: "restorePosition", label: "Goto Position"}
        ],
        configuration: [{
            id: "host",
            label: "Host",
            type: {id: "string"}
        }, {
            id: "port",
            label: "Port",
            type: {id: "string"}
        }, {
            id: "user",
            label: "User",
            type: {id: "string"}
        }, {
            id: "password",
            label: "Password",
            type: {id: "string"}
            /*
             }, {
             id: "updateTime",
             label: "Update Time",
             type: {id: "integer"},
             default: "2000"
             }, {
             id: "hlsLiveStreaming",
             label: "HLS Live Streaming",
             type: {id: "boolean"},
             default: true
             }, {
             id: "webMLiveStreaming",
             label: "webM Live Streaming",
             type: {id: "boolean"},
             default: true
             }, {
             id: "webMPort",
             label: "webM Port",
             type: {id: "integer"},
             */
        }]
    },
    create: function () {
        return new Camera();
    },
    discovery: function (options) {
        var discovery = new CameraDiscovery();

        discovery.options = options;

        return discovery;
    }
};

var q = require('q');
var fs = require('fs');
var https = require('https');
var child_process = require('child_process');
var foscam;
var ffmpeg;
var ffserver;
var deviceDataDirectory;
var moveDuration = 200;
var playlistName = "hls-playlist.m3u8";
var ffserverConfName = "ffserver.conf";
var httpReplaceString = "THINGITHTTPPORT";
var deviceReplaceString = "THINGITDEVICE";


function mkdirSynch(path) {
    var deferred = q.defer();

    try {
        fs.mkdirSync(path);
    } catch (e) {
        if (e.code != 'EEXIST') throw e;
    }

    deferred.resolve();
    return deferred.promise;
}

function CameraDiscovery() {
    var discoveryInterval;

    CameraDiscovery.prototype.start = function () {
        if (this.node.isSimulated()) {
            //TODO simualte auto-discovery for device
        } else {
            this.scanForCameras();
            discoveryInterval = setInterval(this.scanForCameras.bind(this), 10000);
        }
    }

    CameraDiscovery.prototype.stop = function () {
        if (discoveryInterval !== undefined && discoveryInterval) {
            clearInterval(discoveryInterval);
        }
    }

    CameraDiscovery.prototype.scanForCameras = function () {
        this.scanLocalAreaNetworkHosts(function (error, ip, mac) {
            if (error) {
                this.logError(error);
            } else if (ip && !mac) {
                this.logDebug("Ignoring host with unknown MAC address.");
            } else {
                this.getVendorForMac(mac, function (err, vendor) {
                    if (err) {
                        this.logError(ip, err);
                    } else if (vendor) {
                        if (vendor && (-1 < vendor.indexOf("Shenzhen Reecam"))) {
                            this.logInfo("Vendor match found for host "
                                + ip + ": \"" + vendor + "\"");
                            this.testCameraConnection(ip, mac);
                        }
                        else {
                            this.logDebug("Ignoring host " + ip + " with vendor " + vendor + ".");
                        }
                    } else {
                        this.logDebug("No vendor found for IP " + ip + ", trying to connect anyway.");
                        this.testCameraConnection(ip, mac);
                    }
                }.bind(this));
            }
        }.bind(this));
    }

    /**
     * Searches the ARP entries for MAC addresses in the same subnet as the computer the code is running on.
     *
     * @param callback Invokes the callback for each identified MAC address. First parameter is an error,
     *                  second the ip address, third the host.
     */
    CameraDiscovery.prototype.scanLocalAreaNetworkHosts = function (callback) {
        var arp = require('node-arp');
        var network = require('network');

        network.get_active_interface(function (err, obj) {
            if (err) {
                this.logError(err);
                callback(err, false, false);
            } else {
                var myIp = obj.ip_address;
                this.logDebug("My IP address determined as " + myIp);
                var subnet = myIp.substring(0, myIp.lastIndexOf(".") + 1);
                this.logDebug("Scanning for hosts in IP range " + subnet + "1 to " + subnet + "254.");

                for (var i = 1; i < 255; i++) {
                    (function () {
                        var currentIP = subnet + i;

                        if (currentIP != myIp) {
                            arp.getMAC(currentIP, function (err, mac) {
                                if (err) {
                                    this.logError(currentIP, err);
                                } else {
                                    if (mac !== undefined && mac && ("(incomplete)" != mac)) {
                                        this.logDebug ("MAC address found for IP " + currentIP + ": " + mac);
                                        callback(false, currentIP, mac);
                                    }
                                }
                            }.bind(this));
                        }
                    }.bind(this))();
                }
            }
        }.bind(this))
    }

    /**
     * Retrieves the vendor name for a MAC address.
     * @param mac       The MAC address to look up.
     * @param callback  Invoked with return values with first parameter an error, second the vendor name.
     */
    CameraDiscovery.prototype.getVendorForMac = function (mac, callback) {
        this.logDebug("Looking up vendor for MAC address " + mac + ".");
        var data = "";

        var options = {
            hostname: 'www.macvendorlookup.com',
            port: 443,
            path: '/api/v2/' + mac,
            method: 'GET',
            rejectUnauthorized: false
        };

        var req = https.request(options, function (res) {
            res.on('data', function (chunk) {
                data += chunk;
            }.bind(this));

            res.on('end', function () {
                var vendor;

                if ("" !== data) {
                    var vendorLookup = JSON.parse(data);

                    if ((vendorLookup !== undefined && vendorLookup) &&
                        (vendorLookup[0] !== undefined && vendorLookup[0]) &&
                        (vendorLookup[0].company !== undefined && vendorLookup[0].company)) {
                        vendor = vendorLookup[0].company;
                        this.logDebug("Vendor for MAC address " + mac + " identified as " + vendor + ".");
                        callback(false, vendor);
                    }
                } else {
                    this.logDebug("Vendor for MAC address " + mac + " not identified.");
                    callback(false, false);
                }
            }.bind(this));
        }.bind(this));

        req.end();

        req.on('error', function (e) {
            this.logError("MAC based vendor lookup failed for MAC address " + mac + ".", e);
            callback(e, false);
        });
    }

    CameraDiscovery.prototype.testCameraConnection = function (host, mac) {
        this.logDebug("Testing connection to host " + host + ".");
        var discoveryFoscam = require('foscam');

        discoveryFoscam.setup({
            host: host,
            port: 80,
            user: "admin",
            pass: ""
        }, function (status) {
            if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                this.logError("Can't connect to suspected FOSCAM camera host at " + host + " with default credentials.");

                discoveryFoscam.setup({
                    host: host,
                    port: 80,
                    user: "thingit",
                    pass: "[th1ng-1t]"
                }, function (status) {
                    if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                        this.logError("Can't connect to FOSCAM camera at " + host + " with [thing-it] credentials." +
                            " Host skipped. ");
                    }
                    else if (status.alias !== undefined && status.alias) {
                        this.logInfo("Confirmed host " + host + " as FOSCAM camera with alias " + status.alias + ".");
                        this.advertiseCamera(host, 80, "thingit", "tigniht", mac);
                    }
                    else {
                        this.logError("Retrieved unexpected result from suspected FOSCAM camera at " + host +
                            ". Host skipped.");
                        this.logDebug(status);
                    }
                }.bind(this));
            }
            else if (status.alias !== undefined && status.alias) {
                this.logInfo("Confirmed host " + host + " as FOSCAM camera with alias " + status.alias + ".");
                this.advertiseCamera(host, 80, "admin", "", mac);
            }
            else {
                this.logError("Retrieved unexpected result from suspected FOSCAM camera at " + host +
                    ". Host skipped.");
                this.logDebug(status);
            }
        }.bind(this));

    }

    CameraDiscovery.prototype.advertiseCamera = function (host, port, user, pass, mac) {
        var foscamCamera = new Camera();
        //TODO clarify defaultconfig foscamCamera.configuration = this.defaultConfiguration;
        foscamCamera.configuration = {};
        foscamCamera.configuration.host = host;
        foscamCamera.configuration.port = port;
        foscamCamera.configuration.user = user;
        foscamCamera.configuration.pass = pass;
        foscamCamera.configuration.uuid = mac;
        foscamCamera.configuration.hlsLiveStreaming = false;
        foscamCamera.configuration.webMLiveStreaming = false;
        this.logDebug("FOSCAM camera", foscamCamera);
        this.advertiseDevice(foscamCamera);
    }
}

/**
 *
 */
function Camera() {
    /**
     *
     */
    Camera.prototype.start = function () {
        var deferred = q.defer();

        this.state = {};
        this.logDebug(__dirname);

        if (this.configuration.hlsLiveStreaming === undefined) {
            this.configuration.hlsLiveStreaming = true;
        }

        if (this.configuration.webMLiveStreaming === undefined) {
            this.configuration.webMLiveStreaming = true;
        }

        if (this.configuration.webMPort === undefined || !this.configuration.webMPort) {
            this.configuration.webMPort = 3002;
        }

        // Create directory for snapshot images and streaming buffer
        if (this.node.options.dataDirectory !== undefined && this.node.options.dataDirectory) {
            deviceDataDirectory = this.node.options.dataDirectory + "/devices/" + this.id;
            mkdirSynch(this.node.options.dataDirectory);
            mkdirSynch(this.node.options.dataDirectory + "/devices");
            mkdirSynch(deviceDataDirectory);

            this.imageIndex = 0;
            this.rotateIndex = 0;

            this.configuration.port = this.configuration.port || 80;
            this.configuration.user = this.configuration.user || "admin";
            this.configuration.password = this.configuration.password || "";

            if (this.isSimulated()) {
                deferred.resolve();
            } else {
                this.logDebug("Starting FOSCAM camera with configuration ", this.configuration);

                this.state.videoCGI = "http://" + this.configuration.host + ":" + this.configuration.port +
                    "/videostream.cgi?user=" + this.configuration.user + "&pwd=" + this.configuration.password;

                this.logInfo("Video CGI: " + this.state.videoCGI);

                if (!foscam) {
                    foscam = require('foscam');
                }

                foscam.setup({
                    host: this.configuration.host,
                    port: this.configuration.port,
                    user: this.configuration.user,
                    pass: this.configuration.password
                }, function (status) {
                    this.logDebug("Status :", status);

                    if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                        this.logError("Can't connect to FOSCAM camera at " + this.configuration.host + ":"
                            + this.configuration.port + " for control.");
                        this.logError(status);
                        this.startStreaming();
                    }
                    else if (typeof status !== undefined && status) {
                        this.foscamStatus = status;
                        this.logInfo("Connected to FOSCAM camera with alias " + this.foscamStatus.alias +
                            " at IP address " + this.configuration.host + ".");
                        this.flipImage();
                        this.flipImageInterval = setInterval(function () {
                                this.flipImage()
                            }.bind(this),
                            this.configuration.updateTime);
                        this.startStreaming();
                    }
                    else {
                        this.logError("Retrieved unexpected result from FOSCAM API.");
                        this.logError(status);
                    }
                }.bind(this));

                deferred.resolve();
            }
        } else {
            logError("Data directory required for video streaming files not defined, cannot start FOSCAM device.");
            deferred.resolve();
        }


        return deferred.promise;
    };

    /**
     *
     *
     */
    Camera.prototype.stop = function () {
        this.logDebug("FOSCAM stop called");
        clearInterval(this.flipImageInterval);

        if (ffmpeg) {
            ffmpeg.kill();
        }
        if (ffserver) {
            ffserver.kill();
        }
    };

    Camera.prototype.startStreaming = function () {
        var deferred = q.defer();

        if (this.configuration.webMLiveStreaming || this.configuration.hlsLiveStreaming) {

            var ffmpegVariables = [
                "-i", "http://" + this.configuration.user + ":" + this.configuration.password + "@" +
                this.configuration.host + ":" + this.configuration.port + "/videostream.asf"
            ];

            if (this.configuration.hlsLiveStreaming) {
                this.state.playlist = "/data/devices/" + this.id + "/" + playlistName;

                fs.createReadStream(__dirname + "/data/" + playlistName).pipe(
                    fs.createWriteStream(deviceDataDirectory + "/" + playlistName));

                ffmpegVariables = ffmpegVariables.concat([
                    "-c:a", "aac", "-strict", "experimental", "-ac", "2",
                    "-b:a", "96k", "-ar", "44100", "-c:v", "libx264",
                    "-pix_fmt", "yuv420p", "-preset", "ultrafast", "-profile:v",
                    "baseline", "-level", "1.3", "-maxrate", "192k",
                    "-bufsize", "1M", "-crf", "18", "-r", "24", "-g", "72",
                    "-f", "hls", "-hls_time", "1", "-hls_list_size", "2",
                    "-hls_wrap", "4", "-s", "320x240", deviceDataDirectory + "/320x240.m3u8",
                    "-c:a", "aac", "-strict", "experimental", "-ac", "2",
                    "-b:a", "96k", "-ar", "44100", "-c:v", "libx264",
                    "-pix_fmt", "yuv420p", "-preset", "ultrafast", "-profile:v",
                    "baseline", "-level", "3.1", "-maxrate", "1M",
                    "-bufsize", "3M", "-crf", "18", "-r", "24", "-g", "72",
                    "-f", "hls", "-hls_time", "1", "-hls_list_size", "2",
                    "-hls_wrap", "4", "-s", "640x480", deviceDataDirectory + "/640x480.m3u8"
                ]);
            }

            if (this.configuration.webMLiveStreaming) {
                fs.readFile(__dirname + "/data/" + ffserverConfName, 'utf8', function (err, data) {
                    var deferred = q.defer();

                    if (err) {
                        deferred.resolve();
                        this.logError(err);
                    } else {
                        var result = data.replace(/THINGITHTTPPORT/g, this.configuration.webMPort);
                        result = result.replace(/THINGITDEVICE/g, this.id);

                        fs.writeFile(deviceDataDirectory + "/" + ffserverConfName, result, 'utf8', function (err) {
                            var deferred = q.defer();

                            if (err) {
                                deferred.resolve();
                                this.logError("Error creating FFserver configuration.", err);
                            }
                            else {
                                this.logDebug("Successfully written FFserver configuration.");

                                ffserver = child_process.spawn("ffserver", [
                                    "-f", deviceDataDirectory + "/" + ffserverConfName
                                ], {detached: false});

                                ffserver.stdout.on("data", function (data) {
                                    this.logDebug("FFserver received data.", data);
                                }.bind(this));

                                ffserver.stderr.on("data", function (data) {
                                    this.logDebug("FFserver Standard Error Out -> " + data);
                                }.bind(this));

                                ffserver.on("exit", function (code) {
                                    this.logError("FFserver terminated with code " + code);
                                }.bind(this));

                                ffserver.on("error", function (e) {
                                    this.logError("FFserver system error: " + e);
                                }.bind(this));
                                deferred.resolve();
                            }
                        }.bind(this));

                        deferred.resolve();
                    }

                    return deferred.promise;
                }.bind(this));

                var webMTarget = "http://localhost:" + this.configuration.webMPort + "/" + this.id + ".ffm";
                this.logDebug(webMTarget);
                ffmpegVariables = ffmpegVariables.concat(webMTarget);
            }

            if (ffmpeg) {
                this.logInfo("Stopping existing FFmpeg process.");
                ffmpeg.kill();
            }

            ffmpeg = child_process.spawn("ffmpeg", ffmpegVariables, {detached: false});

            ffmpeg.stdout.on("data", function (data) {
                this.logDebug("FFmpeg received data.");
                this.writeData(data);
            }.bind(this));

            ffmpeg.stderr.on("data", function (data) {
                this.logDebug("FFmpeg Standard Error Out -> " + data);
            }.bind(this));

            ffmpeg.on("exit", function (code) {
                this.logError("FFmpeg terminated with code " + code);
            }.bind(this));

            ffmpeg.on("error", function (e) {
                this.logError("FFmpeg system error: " + e);
            }.bind(this));

            deferred.resolve();
        } else {
            deferred.resolve();
            this.logDebug("Streaming not requested - skipping FFmpeg and FFserver setup.");
        }

        return deferred.promise;
    }

    /**
     *
     */
    Camera.prototype.flipImage = function () {
        this.imageIndex = (this.imageIndex + 1) % 3;
        this.rotateIndex = (this.rotateIndex + 1) % 2;

        if (!this.isSimulated()) {
            this.logDebug("Retrieving next snapshot.");
            this.snapshotLocation = deviceDataDirectory + "/snapshotImage" + this.rotateIndex + ".jpg";
            this.state.snapshotImage = "/data/devices/" + this.id + "/snapshotImage" + this.rotateIndex + ".jpg";
            foscam.snapshot(this.snapshotLocation, function (status) {
                this.logDebug("Snapshot retrieved. ", status);
                this.publishStateChange();
            }.bind(this));
        } else {
            this.logDebug("Simulation of flipImage.");
            fs.createReadStream(__dirname + "/data/snapshotImage" + this.imageIndex + ".png").pipe(
                fs.createWriteStream(deviceDataDirectory + "/snapshotImage" + this.rotateIndex + ".png"));
        }
    }

    /**
     *
     */
    Camera.prototype.setState = function (state) {
        this.state = state;
    };

    /**
     *
     */
    Camera.prototype.getState = function () {
        return this.state;
    };

    /**
     *
     */
    Camera.prototype.video = function (req, res) {
        if (this.isSimulated()) {
            this.logDebug("Piping file");
            this.pipeFile(req, res, __dirname + "/data/spaceship.m4v", "video/mp4");
        } else {
            this.logDebug("Piping playlist file for HLS.");
            this.pipeFile(req, res, deviceDataDirectory + "/hls-playlist.m3u4", "application/x-mpegURL");
        }
    };

    /**
     *
     */
    Camera.prototype.panLeft = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.pan = Math.max(-180, this.state.pan - angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position left.");

            // For unknown reasons, camera control for left and right is opposite to expectation.
            foscam.control.decoder("right", function () {
                this.logDebug("Camera moving left.");
                setTimeout(function () {
                    foscam.control.decoder("stop left", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving left.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.panRight = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.pan = Math.min(180, this.state.pan + angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position right.");

            // For unknown reasons, camera control for left and right is opposite to expectation.
            foscam.control.decoder("left", function () {
                this.logDebug("Camera moving right.");
                setTimeout(function () {
                    foscam.control.decoder("stop right", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving right.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.tiltUp = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.tilt = Math.min(180, this.state.tilt + angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position up.");
            foscam.control.decoder("up", function () {
                this.logDebug("Camera moving up.");
                setTimeout(function () {
                    foscam.control.decoder("stop up", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving up.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.tiltDown = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.tilt = Math.max(-180, this.state.tilt - angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position down.");
            foscam.control.decoder("down", function () {
                this.logDebug("Camera moving down.");
                setTimeout(function () {
                    foscam.control.decoder("stop down", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving down.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.savePosition = function (parameters) {
        if (this.isSimulated()) {
            this.flipImage();
        } else {
            this.logDebug("Saving position.");
            foscam.preset.set(16, function (status) {
                if (status !== undefined && status) {
                    if (status == "ok.") {
                        this.logDebug("Position saved.");
                    }
                    else {
                        this.logDebug("Position not saved: ", status);
                    }
                }
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.restorePosition = function (parameters) {
        if (this.isSimulated()) {
            this.flipImage();
        } else {
            this.logDebug("Restoring position.");
            foscam.preset.go(16, function (status) {
                if (status !== undefined && status) {
                    if (status == "ok.") {
                        this.logDebug("Restored position.");
                    }
                    else {
                        this.logError("Error restoring position: ", status);
                    }
                }
            }.bind(this));
        }
    };
}
